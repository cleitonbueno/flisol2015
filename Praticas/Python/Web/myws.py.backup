#! /usr/bin/python


import BaseHTTPServer
import os, sys, re
from mimetypes import types_map
import urlparse



class HandlerWS( BaseHTTPServer.BaseHTTPRequestHandler ):
	server_version= "HandlerWSFLISOL2015/1.1"

	def do_GET( self ):
		output_page = ""
		self.log_message( "Command: %s Path: %s Headers: %r" % ( self.command, self.path, self.headers.items() ) )

		try:
			parsed_path = urlparse.urlparse(self.path)
			message_parts = [
				'CLIENT VALUES:',
				'client_address=%s (%s)' % (self.client_address, self.address_string()),
				'command=%s' % self.command,
				'path=%s' % self.path,
				'real path=%s' % parsed_path.path,
				'query=%s' % parsed_path.query,
				'request_version=%s' % self.request_version,
				'',
				'SERVER VALUES:',
				'server_version=%s' % self.server_version,
				'sys_version=%s' % self.sys_version,
				'protocol_version=%s' % self.protocol_version,
				'',
				'HEADERS RECEIVED:',
			]
			for name, value in sorted(self.headers.items()):
				message_parts.append('%s=%s' % (name, value.rstrip()))
			message_parts.append('')
			message = '\r\n'.join(message_parts)
			self.send_response(200)
			self.end_headers()
			self.wfile.write(message)
			return











			if self.path == "/" or self.path == "/index" or self.path == "/index.html":
				self.path = "index.html"
			elif self.path == "/gpio" or self.path == "/gpio.html":
				self.sendPage("text/html",parsed_path.query)
				#self.path = "gpio.html"
				#'query=%s' % parsed_path.query
			elif self.path == "/cpu" or self.path == "/cpu.html":
				cpu_output = get_cpu_info()
				for cpu_list in cpu_output:
					output_page += "<h3>%s => %s</h3><br>" % (cpu_list[0],cpu_list[1])
				output_page += "<a href=\"/\">voltar</a>"
				self.sendPage("text/html", output_page)			


			fname,ext = os.path.splitext(self.path)
			if ext in (".html", ".css"):
				with open(os.path.join(os.getcwd(),self.path)) as f:
					self.send_response(200)
					self.send_header('Content-type', types_map[ext])
					self.end_headers()
					self.wfile.write(f.read())
			return
		except IOError:
			self.send_error(404)
	
	def do_POST( self ):
		self.log_message( "Command: %s Path: %s Headers: %r" % ( self.command, self.path, self.headers.items() ) )
		if self.headers.has_key('content-length'):
			length= int( self.headers['content-length'] )
			self.dumpReq( self.rfile.read( length ) )
		else:
			self.dumpReq( None )

	def dumpReq( self, formInput=None ):
		response = "<html><head></head><body>"
		response += "<p>HTTP Request</p>"
		response += "<p>self.command= <tt>%s</tt></p>" % ( self.command )
		response += "<p>self.path= <tt>%s</tt></p>" % ( self.path )
		response += "</body></html>"
		self.sendPage( "text/html", response )
	
	def sendPage( self, type, body ):
		self.send_response( 200 )
		self.send_header( "Content-type", type )
		self.send_header( "Content-length", str(len(body)) )
		self.end_headers()
		self.wfile.write( body )

"""
	Funcao para abrir o /proc/cpuinfo e baseado nas palavras-chaves
	em cpu_keywords[], apos filtrar e cortar a sauda split(":")[1]
	o resultado ira para a lista output_cpu_info
"""
def get_cpu_info():
	cpu_keywords = ["model name", "Features", "flags", "Hardware", "Revision"]
	output_cpu_info = []
	with open('/proc/cpuinfo', 'r') as fl_cpu:
		for line in fl_cpu.readlines():
			output_cpu_info += [[cpu_item,line.split(":")[1]] for cpu_item in cpu_keywords if cpu_item in line]
	return output_cpu_info


def get_gpio(_pin):
	with open('/sys/class/gpio/gpio%d/value', 'r') as fl_cpu:
		view_my_file = my_file.read()
	return view_my_file


def set_gpio(_pin, _value):
	#with open(target_path, 'w') as my_file:
	with open('/sys/class/gpio/gpio"+_pin+"/value', 'w') as my_fdpin:
		my_fdpin.write(_value)


def help_usage():
	print "\tsys.argv[0] - Guia de Ajuda"
	sys.exit(0)

	
def httpd(port):
	handler_class=HandlerWS
	server_address = ('', port)

	try:
		wserver = BaseHTTPServer.HTTPServer(server_address, handler_class)
		wserver.serve_forever()
	except Exception, err:
		print "Error:%s" %err
	except KeyboardInterrupt:
		print "\n\nServidor recebeu um sinal, interrompendo e desligando...\n"
		wserver.socket.close()


if __name__ == "__main__":

	ws_port=80

	if len(sys.argv) >= 2:
		ws_port=int(sys.argv[1])
		if isinstance(ws_port, (long, int)):
			print "Aplicacao "+sys.argv[0]+" subindo na porta "+str(ws_port)
			httpd(ws_port)
		else:
			print "Erro: Porta invalida "+sys.argv[1]
			sys.exit(1)
	else:
		print "Aplicacao "+sys.argv[0]+" subindo na porta "+str(ws_port)
		httpd(ws_port)
